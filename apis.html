<!DOCTYPE html>
<html lang ="en-GB">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>APIs</title>
		<link rel="stylesheet" type="text/css" href="style.css">

		<!-- stylesheet for Google Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap" rel="stylesheet">

		<!-- Load an icon library to show a hamburger menu (bars) on small screens -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	</head>

	<body>
		<main>
			<nav class="topnav" id="myTopnav" aria-label="primary">
				<a href="index.html">Home</a>
				<a href="html.html">HTML</a>
				<a href="css.html">CSS</a>
				<a href="javascript.html">JavaScript</a>
				<a href="react.html">React</a>
				<a href="apis.html" class="active">APIs</a>
				<a href="backend.html">Backend</a>
				<a href="workflow.html">Workflow</a>
				<a href="javascript:void(0);" class="icon" onclick="myFunction()">
					<i class="fa fa-bars"></i>
				  </a>
			</nav>

			<div class="container">

				<!-- sidebar content in here -->
				<div class="sidebar">
					<nav aria-label="secondary">
					 	<h3 id="navHeader">About</h3>
					   <p class="center-pink-text">Simple site to store a trainee web dev's notes</p>
					   <img src="./Images/rubber-duck.jpg" alt="Rubber duck" loading="lazy">
						<hr><br>
				    	<h3 class="navSectionHeader">Useful Links</h3>
					    <ul>
					    	<li><a href="https://www.udemy.com/course/the-complete-web-developer-zero-to-mastery/learn/" target="_blank" rel="noopener">ZTM Udemy course</a></li>
							<li><a href="https://zerotomastery.io/resources/" target="_blank" rel="noopener">ZTM Resources</a></li>
							<li><a href="https://github.com/catehardy/" target="_blank" rel="noopener">My GitHub</a></li>
							<li><a href="https://caniuse.com/" target="_blank" rel="noopener">Can I Use?</a></li>
							<li><a href="https://codepen.io/" target="_blank" rel="noopener">Codepen.io</a></li>
							<li><a href="https://replit.com/@CateHardy/" target="_blank" rel="noopener">Replit</a></li>
						</ul>
						<hr><br>
					</nav>
			   </div>

			   <div class="mainContent">
					<header><h1 class="header">APIs</h1></header>
					<p>"As a developer, a lot of our work is just pulling data from APIs." <em>- Wes Bos</em></p>
					<h2 class="pink-heading">Table of Contents</h2>
					<ol>
						<li><a href="#apis">APIs</a></li>	
						<li><a href="#http-https">HTTP / HTTPS</a></li>
						<li><a href="#json">JSON</a></li>
						<li><a href="#ajax">AJAX</a></li>
						<li><a href="#fetch">Fetch API</li>
						<li><a href="#promises">Promises</a></li>
						<li><a href="#async-await">Async/await</a></li>
					</ol>
					<br>

					<h2 class="pink-heading" id="apis">APIs</h2>
					<p><strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface</p>
					<p>APIs are mechanisms that enable two software components to communicate with each other using a set of definitions and protocols. For example, the weather bureau’s software system contains daily weather data. The weather app on your phone “talks” to this system via APIs and shows you daily weather updates on your phone.</p>
					<p>API architecture is usually explained in terms of client and server. The application sending the request is called the client, and the application sending the response is called the server. So in the weather example, the bureau’s weather database is the server, and the mobile app is the client.</p>
					<img src="./Images/api.png" alt="How an API works: diagram">
					<h3>REST APIs (aka RESTful APIs)</h3>
					<p>There are several different ways that APIs can work, depending on when and why they were created. The most popular way nowadays is <strong>REST</strong>.</p>
					<p>REST stands for <strong>R</strong>epresentational <strong>S</strong>tate <strong>T</strong>ransfer. REST defines a set of functions like GET, PUT, DELETE, etc., that clients can use to access server data using HTTP.</p>
					<p>The main feature of a REST API is statelessness. Statelessness means that servers do not save client data between requests. When systems follow the REST paradigm, the server does not need to know anything about what state the client is in and vice versa. In this way, both the server and the client can understand any message received, even without seeing previous messages.</p>
					<p>This constraint of statelessness is enforced through the use of resources, rather than commands. Resources are the nouns of the Web - they describe any object, document, or thing that you may need to store or send to other services</p>
					<h3>Resources for APIs:</h3>
					<ul>
						<li><a href="https://aws.amazon.com/what-is/api/" target="_blank" rel="noopener">What is an API?</a></li>
						<li><a href="https://www.youtube.com/watch?v=-MTSQjw5DrM" target="_blank" rel="noopener">RESTful APIs in 100 Seconds (YouTube)</a></li>
						<li><a href="https://www.baeldung.com/rest-vs-websockets" target="_blank" rel="noopener">REST vs WebSockets</a></li>
						<li><a href="https://wesbos.com/javascript/13-ajax-and-fetching-data/74-ajax-and-apis" target="_blank" rel="noopener">Wes Bos: AJAX and APIs</a></li>
					</ul>
					<br>

					<h2 class="pink-heading" id="http-https">HTTP / HTTPS</h2>
					<p>HTTPS - <strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure.</p>
					<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener">HTTP is a protocol (system of rules) for fetching resources such as HTML documents</a>.</p>
					<p>It's the foundation of any data exchange on the Web and it is a client-server protocol, which means requests are initiated by the recipient, usually the Web browser. A complete document is reconstructed from the different sub-documents fetched - for instance, text, layout description, images, videos, scripts, and more.</p>
					<p>HTTPS is a secure version of the HTTP protocol, using the SSL/TLS protocol for encryption and authentication.</p>
					<p><strong>HTTP methods:</strong> GET, POST PUT, DELETE</p>
					<p>In general, GET requests are for getting data, POST requests are for sending data, PUT requests are for updating data and DELETE requests are for deleting data.</p>
					<br>

					<h2 class="pink-heading" id="json">JSON</h2>
					<p>JSON - <strong>JS</strong> (JavaScript) <strong>O</strong>bject <strong>N</strong>otation.</p>
					<p>The most common and easy way to transport data is in JSON format in the body of the request. JSON is a format that represents JavaScript objects as strings and is built into the JavaScript language with some handy methods:</p>
					<ul>
						<li>JSON.stringify(obj) — turns a JS object into a JSON string</li>
						<li>JSON.parse(string) — turns a JSON string into a JavaScript object</li>
					</ul>
					<p>Most of the time, when your frontend sends some data to the backend it will be formatted into JSON, and when your backend receives that data it will be parsed from JSON back into a JavaScript object. It's the same in the other direction: when your backend sends some data to the frontend it will be formatted into JSON, and when your frontend receives that data it will be parsed from JSON back into a JavaScript object.</p>
					<p><strong>Note:</strong> JSON is neither frontend nor backend. It is a data format or structure used to pass data between the frontend and backend. It can also be used to transfer data between multiple backends or frontends.</p>
					<br>
					<p>An alternative to JSON is XML (e<strong>x</strong>tensible <strong>m</strong>arkup <strong>l</strong>anguage). However, JSON is now more popular.</p>
					<img src="./Images/json-xml.png" alt="JSON vs XML data">
					<br>

					<h2 class="pink-heading" id="ajax">AJAX</h2>
					<p>AJAX - <strong>A</strong>synchronous <strong>Ja</strong>vaScript <strong>X</strong>ML.</p>
					<p>Ajax is a set of web development techniques that uses various web technologies on the client-side to create asynchronous web applications.</p>
					<p>With Ajax, web applications can send and retrieve data from a server asynchronously (in the background) without interfering with the display and behaviour of the existing page. By decoupling the data interchange layer from the presentation layer, Ajax allows web pages and, by extension, web applications, to change content dynamically without the need to reload the entire page.</p>
					<p>In simple terms, working asynchronously means that your code continues to run while the targeted part of your web page is trying to reload (compared to synchronously, which blocks your code from running until that part of your page is done reloading).</p>
					<p><strong>Note:</strong> In practice, modern implementations commonly utilize JSON instead of XML.</p>
					<p class="pink-text-border">The term Ajax has come to represent a broad group of Web technologies that can be used to create a Web application which communicates with a server in the background, without interfering with the current state of the page.</p>
					<h3>Shortest description:</h3>
					<p>AJAX is a technique for accessing web servers from a web page - a frontend tool used to communicate with the backend.</p>
					<br>
					<h2 class="pink-heading" id="fetch">Fetch API</h2>
					<p>Fetch is an interface for making an AJAX request in JavaScript. It is implemented widely by modern browsers and is used to call an API.</p>
					<p><strong>Example uses:</strong> loading texts, images, or structured data asynchronously, to update an HTML page.</p>
					<p>As a newer native JavaScript API, Fetch allows you to make network requests similar to the older XMLHttpRequest API. According to Google Developers Documentation, Fetch makes it easier to make asynchronous requests and handles responses better than XMLHttpRequest.</p>
					<p>The main difference between Fetch and XMLHttpRequest is that the Fetch API uses Promises, and so avoids <a href="https://medium.com/@wendell_adriel/from-highway-to-callback-hell-to-stairway-to-async-await-heaven-e90f73309ed4" target="_blank" rel="noopener">callback hell</a>. The Promise object greatly simplifies the code, especially if used in conjunction with <a href="#async-await">async/await</a>.</p>
					<p>The fetch() method takes one mandatory argument: the path to the resource you want to fetch. It returns a <strong>Promise</strong> that resolves to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noopener">Response</a> to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an <strong>init</strong> options object as the second argument (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noopener">Request</a>).</p>
					<h3>An example fetch request:</h3>
<pre>
fetch(url)
  .then(response => response.json())
  .catch(err => console.log(err))
</pre>
						<h3>Resources for Fetch() method:</h3>
					<ul>
						<li><a href="https://www.freecodecamp.org/news/how-to-use-fetch-api/" target="_blank" rel="noopener">How to Use Fetch to Make AJAX Calls in JavaScript</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">MDN Docs: Fetch API</a></li>
					</ul>
					<br>

					<h2 class="pink-heading" id="promises">Promises</h2>
					<p>A Promise is a special JavaScript object. It produces a value after an asynchronous (aka, async) operation completes successfully, or an error if it does not complete successfully due to time out, network error, and so on.</p>
					<p>A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.</p>
					<p>A Promise is always in one of these states:
						<ul>
							<li><strong>pending:</strong> initial state, neither fulfilled nor rejected</li>
							<li><strong>fulfilled:</strong> meaning that the operation was completed successfully</li>
							<li><strong>rejected:</strong> meaning that the operation failed</li>
						</ul>
					<p>Successful call completions are indicated by the resolve function call, and errors are indicated by the reject function call.</p>
					<br>
					<h3>Some examples of times when promises are useful:</h3>
					<ul>
						<li><a href="https://blog.hubspot.com/website/api-calls" target="_blank" rel="noopener">Making API calls</a></li>
						<li><a href="http://www.javascriptkit.com/javatutors/javascriptpromises.shtml" target="_blank" rel="noopener">Loading an image</a></li>
					</ul>
					<br>
					<h3>Structure of a Promise</h3>
					<p>You can create a promise using the promise constructor like this:</p>
<pre>
const promise = new Promise((resolve, reject) => {    
    // Make an asynchronous call and either resolve or reject
});
</pre>
					</p>
					<br>
					<h3>Using the Promise.all method</h3>
					<p>Promise.all is actually a promise that takes an array of promises as an input (an iterable). Then it gets resolved when all the promises get resolved or any one of them gets rejected. Here's an example:</p>
					<img src="./Images/promise-all.png" alt="Screenshot of code showing Promise.all method">
					<p><strong>Note:</strong> We can now use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled">Promise.allSettled</a> instead, if we want to return any Promises which resolved, even if some were rejected.</p>
					<br>
					<h3>Using the Promise .finally() method</h3>
					<p>The .finally() method is always executed whether the promise is fulfilled or rejected. In other words, the .finally() method is executed when the promise is settled.</p>
					<p>The .finally() method was introduced in ES2018. In the .finally() method, you can place the code that cleans up the resource when the promise is settled, regardless of its outcome. By using the .finally() method, you can avoid duplicate code in the .then() and .catch() methods.</p>
					<p>Resource: <a href="https://www.javascripttutorial.net/es-next/javascript-promise-finally/" target="_blank" rel="noopener">JavaScript Promise .finally() tutorial</a></p>
					<img src="./Images/promise-finally.png" alt="Screenshot of code showing Promise .finally() method">
					<br>
					<h3>Resources for Promises:</h3>
					<ul>
						<li><a href="https://www.freecodecamp.org/news/javascript-promise-tutorial-how-to-resolve-or-reject-promises-in-js/" target="_blank" rel="noopener">How to Resolve or Reject Promises in JS</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises/" target="_blank" rel="noopener">Using Promises (MDN Web Docs)</a></li>
						<li><a href="https://www.freecodecamp.org/news/promise-all-in-javascript-with-example-6c8c5aea3e32/" target="_blank" rel="noopener">All you need to know about Promise.all</a></li>
					</ul>
					<br>

					<h2 class="pink-heading" id="async-await">Async/await</h2>
					<p>An async function is a function that returns a Promise; it's declared with the async keyword, and the await keyword is permitted within it.</p>
					<p>The benefit of async/await is that it makes code easier to read. The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains. It's syntactic sugar - Promises working under the hood, but a nicer way to code them!</p>
					<p><strong>The same function two ways - 1st with standard Promises and 2nd with async/await Promises:</strong></p>
					<img src="./Images/async-await.png" alt="Screenshot of code showing async-await function">
					<br>
					<h3>Using the 'for await...of' statement</h3>
					<p>This lets you loop through multiple async/await calls.</p>
					<p>Resources:</p>
					<ul>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of" target="_blank" rel="noopener">MDN Web Docs: for await...of</a></li>
						<li><a href="https://stackoverflow.com/questions/59694309/for-await-of-vs-promise-all" target="_blank" rel="noopener">When to use 'for await...of' instead of 'Promises.all'</a></li>
					</ul>
					<p><strong>Example of Promises using 'for await...of':</strong></p>
					<img src="./Images/for-await-of.png" alt="Screenshot of code showing 'for await...of' statement">
					<br>
					<h3>Resources for async/await:</h3>
					<ul>
						<li><a href="https://javascript.info/async-await" target="_blank" rel="noopener">Async/await (JavaScript.info)</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">Async function (MDN Web Docs)</a></li>
					</ul>

					<br><hr><br>
				</div>
			</div>
			<footer>Website made with love by Cate, &copy;2022</footer>
		</main>
		<script type="text/javascript" src="topnav.js"></script>
	</body>
</html>